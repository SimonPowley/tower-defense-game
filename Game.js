class Game {
    constructor(config) {
        this.fps = 60;
        this.running = true;

        // game canvas info
        this.canvas = config.gameCanvas;
        this.ctx = this.canvas.getContext('2d');
        this.canvas.collisions = [];

        // set/create player
        this.canvas.player = config.player || new Player();

        // current map/path
        this.canvas.path = config.path || new Path('map_1');

        // map menu
        this.mapMenu = config.mapMenu;



        //// THINGS TO ADD MAYBE
        //// main/home menu, settings menu, game over (win/lose) menu
        //// sandbox/infinite money mode
        //// keyboard controls (space=pause/play, tower shop hotkeys, etc.)
        //// sound effects
        

        // // THINGS TO CHANGE/FIX
        // // changing round speed can mess with enemy positioning, causing weird behavior at corners
        // // reducing enemy size as health decreases can also mess with positioning/corners
        // // make laser projectile actually do something interesting/different ? (besides being red)
        // // change attack timing (speed 1 = 1 attack per second, etc ?)
        // // or maybe just make projectiles move faster so they don't miss as much ?
        // // first gold generated by mine appears visually, but isn't added to stored gold until more is generated
        // // ninja tower reversal upgrade/effect is kinda wonky sometimes (when reverse effect is > 1)
    }

    init() {
        // there's probably a better/less clunky way to do the event listeners...
        this.canvas.addEventListener('mousedown', this.mouseDown);
        this.canvas.addEventListener('mouseup', this.mouseUp);
        this.canvas.addEventListener('mousemove', this.mouseMove);

        // shop menu
        this.canvas.shop = new Shop({
            pos: {x: 0, y: 0},
            size: {width: 80, height: 320}
        });

        // tower info menu
        this.canvas.info = new Info({
            pos: {x: 400, y: 0},
            size: {width: 80, height: 320}
        });

        // round info/starting round
        this.canvas.round = new Round({
            waypoints: this.canvas.path.waypoints,
            direction: this.canvas.path.direction
        });

        // pause/resume/start round button
        this.canvas.paused = true;
        this.canvas.pauseButton = {
            pos: {x: 5, y: 5},
            size: {width: 30, height: 20}
        }

        // game speed buttons (change game speed)
        this.canvas.speed = 1;
        this.canvas.speed1Button = {
            pos: {x: 40, y: 5},
            size: {width: 15, height: 20}
        }
        this.canvas.speed2Button = {
            pos: {x: 60, y: 5},
            size: {width: 15, height: 20}
        }

        // game settings button (change map/exit game, auto start rounds, sound on/off, etc.)
        // ***** NOT FINISHED YET *****
        this.canvas.settingsButton = {
            pos: {x: 5, y: 30},
            size: {width: 50, height: 15}
        }

        // initialize anything that needs to be
        this.canvas.shop.init(this.canvas);
        this.canvas.info.init();
        this.canvas.path.init(this.canvas);
        this.canvas.round.init(10);

        // start game
        this.runGame();
    }

    endGame() {
        // end current game and return to map selection menu
        this.mapMenu.player.reset();
        this.mapMenu.canvas.loading = undefined;
        this.mapMenu.running = true;
        this.running = false;
    }

    update() {
        // don't update enemies or placed towers if paused
        if (this.canvas.paused) {
            return;
        }

        // player loses all lives, return to map menu
        if (this.canvas.player.lives <= 0) {
            this.endGame();
        }
        // player completes last level, return to map menu
        if (this.canvas.round.round > this.canvas.round.lastRound) {
            this.endGame();
        }

        // update player
        this.canvas.player.update();

        // update tower targeting and shooting
        if (this.canvas.player.towers.length > 0) {
            this.canvas.player.towers.forEach(tower => {
                tower.update(this.canvas.round.enemies, this.ctx, this.canvas.speed, this.timer);
                this.canvas.player.addGold(tower.damage);
                this.canvas.player.addGold(tower.explosionDamage);
            })
        }

        // update enemies
        if (this.canvas.round.enemies.length > 0) {
            this.canvas.round.enemies.forEach(enemy => {
                // spawn enemy if timer >= enemy's spawn time
                if (this.timer >= enemy.age) {
                    enemy.update(this.canvas.player, this.canvas.speed, this.timer);
                    this.canvas.round.update();
                }
            })
        }

        // all enemies killed or leaked, end round
        if (this.canvas.round.enemies.length == 0) {
            this.timer = 0;
            if (this.canvas.round.round <= this.canvas.round.lastRound) {
                this.canvas.player.addGold(this.canvas.round.reward);
                this.canvas.round.update();
                this.canvas.paused = true;
                // remove all bullets from screen, remove tower target
                this.canvas.player.towers.forEach(tower => {
                    tower.target = undefined;
                    tower.lastShot = 0;
                    tower.projectiles = [];
                    tower.explosions = [];
                    if (tower.name == 'mine') {
                        this.canvas.player.addGold(tower.storedGold);
                        tower.storedGold = 0;
                    }
                });
            }
        }
    }

    draw() {
        // draw blank game canvas
        this.ctx.fillStyle = 'white';
        this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);

        //  draw level map
        this.canvas.path.draw(this.ctx);

        //  draw enemies
        if (this.canvas.round.enemies.length > 0) {
            this.canvas.round.enemies.forEach(enemy => {
                enemy.draw(this.ctx);
            })
        }

        // draw player towers
        this.canvas.player.towers.forEach(tower => {
            if (!tower.selected) {
                tower.draw(this.ctx, this.timer);
            }
        })
        // draw player selected tower and selected tower info
        if (this.canvas.player.selected != undefined && this.canvas.player.selected.bought) {
            // draw tower info
            this.canvas.player.selected.draw(this.ctx, this.timer);
            this.canvas.info.draw(this.ctx, this.canvas.player.selected);
        } else {
            this.canvas.info.tower = undefined;
        }

        // draw tower shop
        this.canvas.shop.draw(this.ctx);

        // draw pause/unpause button
        this.ctx.fillStyle = 'white';
        this.ctx.fillRect(this.canvas.pauseButton.pos.x, this.canvas.pauseButton.pos.y, this.canvas.pauseButton.size.width, this.canvas.pauseButton.size.height);
        
        // show resume icon (play triangle) if paused
        if (this.canvas.paused) {
            this.ctx.beginPath();
            this.ctx.moveTo(this.canvas.pauseButton.pos.x + 10, this.canvas.pauseButton.pos.y + 4);
            this.ctx.lineTo(this.canvas.pauseButton.pos.x + this.canvas.pauseButton.size.width - 10, this.canvas.pauseButton.pos.y + this.canvas.pauseButton.size.height / 2);
            this.ctx.lineTo(this.canvas.pauseButton.pos.x + 10, this.canvas.pauseButton.pos.y + this.canvas.pauseButton.size.height - 4);
            this.ctx.closePath();

            this.ctx.lineWidth = 2;
            this.ctx.strokeStyle = 'black'
            this.ctx.stroke();

            this.ctx.fillStyle = 'black';
            this.ctx.fill();
        }
        // show pause icon (pause lines) if unpaused
        else {
            this.ctx.fillStyle = 'black';
            this.ctx.fillRect(this.canvas.pauseButton.pos.x + 9, this.canvas.pauseButton.pos.y + 4, 4, this.canvas.pauseButton.size.height - this.canvas.pauseButton.pos.y - 3);
            this.ctx.fillRect(this.canvas.pauseButton.size.width - 8, this.canvas.pauseButton.pos.y + 4, 4, this.canvas.pauseButton.size.height - this.canvas.pauseButton.pos.y - 3);
            
        }

        // draw game speed 1x and 2x buttons
        this.ctx.fillStyle = 'black';
        if (this.canvas.speed == 1) {
            this.ctx.fillRect(this.canvas.speed1Button.pos.x - 1, this.canvas.speed1Button.pos.y - 1, this.canvas.speed1Button.size.width + 2, this.canvas.speed1Button.size.height + 2)
        } else {
            this.ctx.fillRect(this.canvas.speed2Button.pos.x - 1, this.canvas.speed2Button.pos.y - 1, this.canvas.speed2Button.size.width + 2, this.canvas.speed2Button.size.height + 2);
        }
        this.ctx.fillStyle = 'white';
        this.ctx.fillRect(this.canvas.speed1Button.pos.x, this.canvas.speed1Button.pos.y, this.canvas.speed1Button.size.width, this.canvas.speed1Button.size.height);
        this.ctx.fillRect(this.canvas.speed2Button.pos.x, this.canvas.speed2Button.pos.y, this.canvas.speed2Button.size.width, this.canvas.speed2Button.size.height);
        this.ctx.font = 'bold 12px Arial';
        this.ctx.fillStyle = 'black';
        this.ctx.fillText('1x', this.canvas.speed1Button.pos.x, this.canvas.speed1Button.size.height);
        this.ctx.fillText('2x', this.canvas.speed2Button.pos.x, this.canvas.speed2Button.size.height);

        // draw settings menu button
        this.ctx.fillStyle = 'white';
        this.ctx.fillRect(this.canvas.settingsButton.pos.x, this.canvas.settingsButton.pos.y, this.canvas.settingsButton.size.width, this.canvas.settingsButton.size.height);
        this.ctx.font = 'bold 12px Arial';
        this.ctx.fillStyle = 'black';
        this.ctx.fillText('Settings', this.canvas.settingsButton.pos.x, this.canvas.settingsButton.pos.y + 12);

        // draw selected tower from shop
        if (this.canvas.player.selected != undefined && !this.canvas.player.selected.bought) {
            this.canvas.player.selected.draw(this.ctx);
        }

        // draw player health and money
        this.ctx.font = 'bold 15px Arial';
        this.ctx.fillStyle = 'black';
        this.ctx.fillText('Lives: ' + this.canvas.player.lives, 85, 15);
        this.ctx.fillText('Gold: $' + this.canvas.player.gold, 85, 30);

        // draw round info
        this.canvas.round.draw(this.ctx, this.canvas.info.tower);
    }

    mouseDown(event) {
        event.preventDefault();
        
        // location of mouse press
        this.startX = parseInt(event.offsetX);
        this.startY = parseInt(event.offsetY);

        // player clicks tower in shop
        this.shop.towers.forEach(tower => {
            if (mouseOver(this.startX, this.startY, tower)) {
                // unselect tower if player has one selected
                if (this.player.selected != undefined) {
                    this.player.selected.selected = false;
                }
                this.player.selected = undefined;
                // select a copy of shop tower to move around or buy
                this.player.selectTower(tower.makeCopy());
                return;
                
            }
        })

        function mouseOver(x, y, object) {
            // set tower collision dimensions
            let objectLeft = object.pos.x;
            let objectRight = object.pos.x + object.size.width;
            let objectTop = object.pos.y;
            let objectBottom = object.pos.y + object.size.height;
    
            if (x > objectLeft && x < objectRight && y > objectTop && y < objectBottom) {
                return true;
            }
            return false;
        }
    }

    mouseUp(event) {
        event.preventDefault();

        // location of mouse release
        this.endX = parseInt(event.offsetX);
        this.endY = parseInt(event.offsetY);

        // player tries to place tower from shop
        if (this.player.selected != undefined && !this.player.selected.bought) {
            // check if tower is dropped in shop, remove/cancel buy
            if (checkTowerCollision(this.player.selected, this.shop.dimensions)) {
                this.player.selected = undefined;
                return;
            }

            // check if tower collides with path or shop menu
            for (let i = 0; i < this.collisions.length; i++) {
                if (checkTowerCollision(this.player.selected, this.collisions[i])) {
                    return;
                }
            }
            // check if tower collides with placed towers
            for (let i = 0; i < this.player.towers.length; i++) {
                if (checkTowerCollision(this.player.selected, this.player.towers[i])) {
                    return;
                }
            }

            // place and purchase tower (no collision/invalid placement)
            if (this.player.selected.canPlace) {
                this.player.buyTower();
                return;
            }
        }
        
        // player pause/resumes round
        if (mouseOver(this.endX, this.endY, this.pauseButton)) {
            if (this.paused) {
                this.paused = false;
            } else {
                this.paused = true;
            }
            return;
        }

        // player changes round speed
        if (mouseOver(this.endX, this.endY, this.speed1Button)) {
            this.speed = 1;
            return;
        } else if (mouseOver(this.endX, this.endY, this.speed2Button)) {
            this.speed = 2;
            return;
        }

        // player purchases path 1 upgrade
        if (this.player.selected != undefined && this.player.selected.bought && mouseOver(this.endX, this.endY, this.info.infoButtons.upgrade1Button)) {
            this.player.upgradeTower(1);
            return;
        }

        // player purchases path 2 upgrade
        if (this.player.selected != undefined && this.player.selected.bought && mouseOver(this.endX, this.endY, this.info.infoButtons.upgrade2Button)) {
            this.player.upgradeTower(2);
            return;
        }

        // player changes selected tower priority, or collects gold stored in mine
        if (this.player.selected != undefined && this.player.selected.bought && mouseOver(this.endX, this.endY, this.info.infoButtons.priorityButton)) {
            // reward stored gold if selected tower is a mine
            if (this.player.selected.name == 'mine') {
                if (this.player.selected.projectiles.length > 0) {
                    this.player.addGold(this.player.selected.storedGold);
                    this.player.selected.storedGold = 0;
                    this.player.selected.projectiles = [];
                }
            } else {
                this.player.selected.changePriority();
            }
            return;
        }

        // player sells selected tower
        if (this.player.selected != undefined && this.player.selected.bought && mouseOver(this.endX, this.endY, this.info.infoButtons.sellButton)) {
            // remove tower from player tower list
            this.player.sellTower();
            return;
        }

        // player clicks selected tower info menu
        if (this.player.selected != undefined && this.player.selected.bought && mouseOver(this.endX, this.endY, this.info)) {
            // player clicks info menu (keep menu up)
            if (mouseOver(this.endX, this.endY, {pos: this.info.pos, size: this.info.size})){
                return;
            }
        }

        // player selects (clicks on) placed tower
        this.player.selected = undefined;
        for (let i = 0; i < this.player.towers.length; i++) {
            if (mouseOver(this.endX, this.endY, this.player.towers[i]) && this.player.towers[i].bought) {
                this.player.selectTower(this.player.towers[i]);
                this.player.selected.canPlace = true;
            } else {
                this.player.towers[i].selected = false;
            }
        }

        function checkTowerCollision(tower, object) {
            // set tower collision dimensions
            let towerLeft = tower.pos.x;
            let towerRight = tower.pos.x + tower.size.width;
            let towerTop = tower.pos.y;
            let towerBottom = tower.pos.y + tower.size.height;
    
            if (!(object.left > towerRight || // tower right collides
                object.right < towerLeft || // tower left collides
                object.top > towerBottom || // tower bottom collides
                object.bottom < towerTop)) { // tower top collides
                tower.canPlace = false;
                return true;
            }
            else {
                tower.canPlace = true;
                return false;
            }
        };

        function mouseOver(x, y, object) {
            // set object collision dimensions
            let objectLeft = object.pos.x;
            let objectRight = object.pos.x + object.size.width;
            let objectTop = object.pos.y;
            let objectBottom = object.pos.y + object.size.height;
    
            if (x > objectLeft && x < objectRight && y > objectTop && y < objectBottom) {
                return true;
            }
            return false;
        }
    }

    mouseMove(event) {
        if (this.player.selected == undefined || this.player.selected.bought) {
            this.endX = parseInt(event.offsetX);
            this.endY = parseInt(event.offsetY);
            // show info when mousing over towers in the shop
            this.shop.selected = undefined;
            for (let i = 0; i < this.shop.towers.length; i++) {
                if (mouseOver(this.endX, this.endY, this.shop.towers[i])) {
                    this.shop.selected = this.shop.towers[i];
                }
            }
            return;
        }
        else {
            event.preventDefault();
            let mouseX = parseInt(event.offsetX);
            let mouseY = parseInt(event.offsetY);

            let dx = mouseX - this.startX;
            let dy = mouseY - this.startY;

            this.player.selected.pos.x += dx;
            this.player.selected.pos.y += dy;
            this.player.selected.setDimensions();

            this.startX = mouseX;
            this.startY = mouseY;
        }

        // check if tower collides with path or shop menu
        for (let i = 0; i < this.collisions.length; i++) {
            if (checkTowerCollision(this.player.selected, this.collisions[i])) {
                this.player.selected.canPlace = false;
                return;
            }
        }
        // check if tower collides with placed towers
        for (let i = 0; i < this.player.towers.length; i++) {
            if (checkTowerCollision(this.player.selected, this.player.towers[i])) {
                this.player.selected.canPlace = false;
                return;
            }
        }

        // check if player can afford tower
        if (this.player.gold < this.player.selected.cost) {
            this.player.selected.canPlace = false;
            return;
        }

        function checkTowerCollision(tower, object) {
            // set tower collision dimensions
            let towerLeft = tower.pos.x;
            let towerRight = tower.pos.x + tower.size.width;
            let towerTop = tower.pos.y;
            let towerBottom = tower.pos.y + tower.size.height;
    
            if (!(object.left > towerRight || // tower right collides
                object.right < towerLeft || // tower left collides
                object.top > towerBottom || // tower bottom collides
                object.bottom < towerTop)) { // tower top collides
                tower.canPlace = false;
                return true;
            }
            else {
                tower.canPlace = true;
                return false;
            }
        };

        function mouseOver(x, y, object) {
            // set object collision dimensions 
            let objectLeft = object.pos.x;
            let objectRight = object.pos.x + object.size.width;
            let objectTop = object.pos.y;
            let objectBottom = object.pos.y + object.size.height;
    
            if (x > objectLeft && x < objectRight && y > objectTop && y < objectBottom) {
                return true;
            }
            return false;
        }
    }

    runGame() {
        this.timer = 0;
        // run game loop
        if (this.running) {
            setInterval(() => {
                if (this.running) {
                    // update timer if not paused
                    if (!this.canvas.paused) {
                        this.timer += this.canvas.speed;
                    }
                    this.draw();
                    this.update();
                }
            }, 1000 / this.fps);
        }
    }
}